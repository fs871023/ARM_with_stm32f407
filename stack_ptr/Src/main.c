/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/
#include <stdio.h>

int func_add(int a, int b, int c, int d)
{
	return a + b + c + d;
}

__attribute__((naked)) void change_sp_to_psp(void)
{
	//always use naked function to change sp (stack pointer)
	//make sp = psp

	__asm volatile(".equ SRAM_END, (0x20000000 + (128 * 1024))");
	//find end of sRAM
	__asm volatile(".equ PSP_START, (SRAM_END - 512)");
	//find psp's start addr
	__asm volatile("LDR R0, =PSP_START");
	//init R0, R0 = psp start addr
	__asm volatile("MSR PSP, R0");
	// initialize PSP reg

	__asm volatile("MOV R0, #0X02");
	// set first bit of CONTROL reg
	__asm volatile("MSR CONTROL, R0");
	//change sp reg addr from MSP to PSP
	__asm volatile("BX LR");
	//LR: reg of capturing the return addr. it knows where to go back when the func finished.
}

void generate_exception(void)
{
	__asm volatile("SVC #0X2");
	//trigger svc exception
	//change to handler mode sp = msp

}

int main(void)
{
	//see Startup file
	//first thing after reset: fetch the first entry of the vector table and initialize the MSP reg
	//be sure it is a valid adrr
	//.ld has these symbol in startup file

	//sp now is msp
	change_sp_to_psp();
	//sp now is psp
	int ret;
	ret = func_add(1, 5, 9, 7);
	printf("result: %d\n", ret);
	generate_exception();// in here, sp = MSP. That's because handler mode always use MSP
	//after here sp reg back to PSP addr

	for(;;);
}

void SVC_Handler(void)
{
	printf("in SVC handler\n");
}
