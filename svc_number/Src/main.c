/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
//  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

//write a program to execute an SVC instruction from thread mode
//implement the svc handler to print the svc number used
//increment the svc number by 4 and return it to the thread mode and print it

int main(void)
{
	//1. execute the svc instruction with the argument e.g. #0x5
	//svc should follow an immediate value, which is in the range 0-255(8bit)
	//imm is ignore by the processor, and it can be retrieve by the exception handler
	__asm("SVC #8");//cause the svc exception

	//2. implement the svc handler
	//3. in svc handler extract the svc number and print it use printf
	//4. increment the svc number by 4 and return it to the thread mode

	//make value of R0 to c var
	//the value will not created in stack
	//created in reg instead
//	register uint32_t data __asm("r0");//this var will related to R0
//	printf("data = %ld\n", data);
	// not recommend method.
	//if the reg isn't free, the method will fail

	uint32_t data_new;
	//volatile for no optimization
	__asm volatile("MOV %0, R0": "=r"(data_new) ::);//see inline
	printf("new data = %ld\n", data_new);

	/* Loop forever */
	for(;;);
}
__attribute__((naked)) void SVC_Handler(void)
{
	__asm("MRS R0, MSP");//value of MSP to R0
	//pass the value to c funtion
	__asm("B SVC_Handler_c");//branch to c function
	//R0 will automatically copy to the first argument
	//based on the "procedure call standard for ARM architecture"
}
//copy from starup
void SVC_Handler_c(uint32_t *pBaseOfStackFrame)
{
	printf("In SVC Handler\n");
	//1. get the value of MSP
	//read the stack from MSP, the number we want is in the stack
//	__asm("MRS R0, MSP");//value of MSP to R0
	//but we can't get the value of MSP in C function,
	//because it will broken due to prolog and epilog instruction (see disassembly)
	//**so we should use naked function instead**

	//2. get the number in the return addr by increment by 6
	uint8_t *pReturn_addr = (uint8_t*)pBaseOfStackFrame[6];
	//3. decrement the return addr by 2 to point to
	//opcode of the SVC instruction in the program mem
	pReturn_addr-=2;
	//4.extract the svc number (LSByte of the opcode)
	uint8_t svc_number = *pReturn_addr;
	printf("SVC number is %d\n", svc_number);

	svc_number+=4;
	//store the value in the reg of MSP by using stack frame
	pBaseOfStackFrame[0] = 	svc_number;//location of R0

}
